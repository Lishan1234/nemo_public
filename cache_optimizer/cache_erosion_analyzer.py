import os
import sys
import struct

from option import args

class CacheErosionAnalyzer():
    def __init__(self):
        self.content_dir = args.cra_content_dir
        self.input_video_name = args.cra_input_video_name
        self.dnn_video_name = args.cra_dnn_video_name
        self.compare_video_name = args.cra_compare_video_name
        self.num_cores = args.cra_num_cores

        self.result_dir = os.path.join(self.content_dir, "cra_{}".format(self.input_video_name))
        self.log_dir = os.path.join(self.result_dir, "log")
        self.profile_dir = os.path.join(self.result_dir, "profile")

        os.makedirs(self.result_dir, exist_ok=True)
        os.makedirs(self.log_dir, exist_ok=True)
        os.makedirs(self.profile_dir, exist_ok=True)

        if args.cra_total_frames == 0:
            #TODO: analyze a video by ffmepg and read total number of frames
            print("Need to implement: read the total number of frames from a video")
            sys.exit()
        else:
            self.total_frames = args.cra_total_frames

    #generate cache profiles for CRA: 1 of |GOP| frames is selceted as an anchor point
    def save_cache_profile(self, frame_index):
        cache_profile_path = os.path.join(self.profile_dir, "g{}_i{}.profile".format(self.total_frames, frame_index))
        with open(cache_profile_path, "wb") as f:
            byte_value = 0
            for i in range(self.total_frames):
                if i == frame_index:
                    byte_value += 1 << (i % 8)

                if i % 8 == 7:
                    f.write(struct.pack("=B", byte_value))
                    byte_value = 0

            if self.total_frames % 8 != 0:
                f.write(struct.pack("=B", byte_value))

    def prepare_cache_profiles(self):
        for i in range(self.total_frames):
            self.save_cache_profile(i)

    #run the cache profiles & measure the quality
    #TODO: use Process and Queue for parallel decoding on multi-cores
    def run_cache_profiles(self):
        for i in range(self.total_frames):
            cache_profile_path = os.path.join(self.profile_dir, "g{}_i{}.profile".format(self.total_frames, frame_index))
            cmd = "./vpxdec --codec=vp9 --summary --noblit --threads=1 --frame-buffers=50 --limit=30 --content-dir={} --input-video={}.webm --dnn-video={}.webm --compare-video={}.webm --cache-profile={} --prefix={} --decode-mode=2 --dnn-mode=2 --cache-policy=1 --save-quality".format(self.content_dir, self.input_video_name, self.dnn_video_name, self.compare_video_name, cache_profile_path, "cra")
            os.system(cmd)

    def load_dnn_quality(self):
        dnn_quality = []

        quality_log_path = os.path.join(self.content_dir, "sr_{}".format(self.input_video_name), "log", "quality.log".format(self.total_frames, frame_index))
        with open(quality_log_path, "r") as f:
            quality_log = f.readlines()
            for line in quality_log:
                dnn_quality.append(line.split('\t')[0])

        return dnn_quality

    def load_cache_quality(self):
        cache_qualty = []

        for i in range(self.total_frames):
            quality = []
            quality_log_path = os.path.join(self.log_dir, "quality_g{}_i{}.log".format(self.total_frames, frame_index))
            with open(quality_log_path, "r") as f:
                quality_log = f.readlines()
                for line in quality_log:
                    quality.append(line.split('\t')[0])

            cache_qualty.append(quality)

        return cache_quality

    #calculate cache erosion metrics and save these in a log file
    def analyze_cache_erosion(self):
        #TODO: 1. load quality results, 2. calculate cache erosion metrics, 3. save these metrics
        dnn_quality = self.load_dnn_quality()
        cache_quality = self.load_cache_quality()
        cache_erosion_metrics = {}

        #TODO: add input arguments called cra_window_size (multiple)
        #TODO: calculate cache erosion metrics for each cra_widow_size
        #TODO: save a cache erosion log

        cache_erosion_log_path = os.path.join(self.log_dir, "cache_erosion.log")
        #with open(cache_erosion_log_path, "wb") as f:
        #    for i in range(self.total_frames):

if __name__ == '__main__':
    #TODO: check whether cache profile is corretely generated by loading it in libvpx
    cra = CacheErosionAnalyzer()
    cra.prepare_cache_profiles()
